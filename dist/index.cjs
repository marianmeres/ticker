"use strict";const e=e=>"function"==typeof e,t=(t,s="")=>{if(!e(t))throw new TypeError(`${s} Expecting function arg`.trim())},s=(s=void 0,r=null)=>{const n=t=>e(r?.persist)&&r.persist(t);let o=(()=>{const e=new Map,t=t=>(e.has(t)||e.set(t,new Set),e.get(t)),s=(e,s)=>{if("function"!=typeof s)throw new TypeError("Expecting callback function as second argument");return t(e).add(s),()=>t(e).delete(s)};return{publish:(e,s={})=>{t(e).forEach((e=>e(s)))},subscribe:s,subscribeOnce:(e,t)=>{const r=s(e,(e=>{t(e),r()}));return r},unsubscribeAll:t=>e.delete(t)}})(),c=s;n(c);const i=()=>c,u=e=>{c!==e&&(c=e,n(c),o.publish("change",c))};return{set:u,get:i,update:e=>{t(e,"[update]"),u(e(i()))},subscribe:e=>(t(e,"[subscribe]"),e(c),o.subscribe("change",e))}},r=()=>"undefined"!=typeof window?window.performance.now():Date.now(),n=e=>{if(e=parseInt(e,10),Number.isNaN(e)||e<=0)throw new TypeError("Invalid interval. Expecting positive non-zero number of milliseconds.");return e};exports.createRecursiveTicker=(e,t=1e3,o=!1)=>{const c=e=>t=n(e),i=(e={})=>({started:0,finished:0,error:null,result:null,...e||{}});c(t);const u=s(i());let a=0,l=o;const p=async()=>{const s=r();let n;try{const t=u.get();u.set(i({started:s})),n=await e(t),l&&u.set(i({started:s,finished:r(),result:n}))}catch(e){l&&u.set(i({started:s,finished:r(),error:e}))}l&&(a&&clearTimeout(a),a=setTimeout(p,t))},b={subscribe:u.subscribe,start:()=>(l=!0,!a&&p(),b),stop:()=>(a&&(clearTimeout(a),a=0),l=!1,b),setInterval:e=>(c(e),b)};return o&&b.start(),b},exports.createTicker=(e=1e3,t=!1,o=null)=>{const c=t=>e=n(t);c(e);const i=s(0);let u=0,a=0;const l=()=>{const t=r();a||=t,i.set(Date.now());const s=r()-a,n=s?s-e:0,c=Math.max(0,e-n);u=setTimeout(l,c),a=r(),((...e)=>{"function"==typeof o&&o.apply(null,e)})({_start:t,_duration:s,_offset:n,_nextInterval:c})},p={subscribe:i.subscribe,start:()=>(!u&&l(),p),stop:()=>(i.set(0),u&&(clearTimeout(u),u=0),a=0,p),setInterval:e=>(c(e),p)};return t&&p.start(),p};
